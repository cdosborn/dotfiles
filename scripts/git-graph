#!/bin/bash

usage() {
    echo 'Print the smallest graph from these endpoints';
    echo '';
    echo 'git graph <commit>...';
}

main() {
    local REFS FLAGS FILES;
    FLAGS=(
        '--graph' \
        '--oneline' \
        '--format=format:%C(auto)%h%C(reset)%C(auto)%d%C(reset) %C(auto)%<(50,trunc)%s %C(reset)'
    );

    if [[ "$#" -eq 0 ]]; then
        usage;
        return 0;
    fi

    while [ "$#" -gt 0 ]; do
        if [ "$1" == '--' ]; then
            FILES+=( "$@" );
            break;
        elif [[ "$1" =~ ^- ]]; then
            FLAGS+=( "$1" );
        else
            REFS+=( "$1" );
        fi
        shift;
    done;

    if [ "${#REFS[@]}" -eq 1 ]; then
        REFS+=( HEAD );
    fi

    local MERGE_BASE=$(oldest-merge-base "${REFS[@]}");
    local NEGATION_SET;

    # Only compute negation set, if a merge base exists
    if [ -n "$MERGE_BASE" ]; then

        # We want to show the merge base of the tips, but no further, so we
        # add the parents of the merge base, so we exclude with ^parent
        for parent in $(git log --format=%P $MERGE_BASE -n 1); do
            NEGATION_SET+=( "^$parent" );
        done;

        # If the merge base exists, but has no parents, the merge base is the
        # first commit
        if [ "${#NEGATION_SET[@]}" -eq 0 ]; then
            NEGATION_SET=( "^$MERGE_BASE" );
        fi
    fi

    git log "${FLAGS[@]}" "${NEGATION_SET[@]}" "${REFS[@]}" -- "${FILES[@]}";
}

oldest-merge-base() {
    local COMMON_ANCESTOR="" endpoint1 endpoint2;
    endpoint1="$1";

    # To handle more than 2 endpoints, we compute like so
    # o-m-b(o-m-b(o-m-b($1, $2), $3), ...)
    while [[ "$#" -gt 1 ]]; do
        shift;
        endpoint2="$1";

        while read sha1 <&3  && read sha2 <&4
        do
            if [ "$sha1" == "$sha2" ]; then
                COMMON_ANCESTOR="$sha1";
            else
                # Break at the first occurence where the history diverged
                break;
            fi;

        done 3< <(git rev-list --reverse --first-parent "$endpoint1" --) 4< <(git rev-list --reverse  --first-parent "$endpoint2" -- )

        # When comparing the two histories from their starts, we never found
        # a branching off point
        if [ -z "$COMMON_ANCESTOR" ]; then
            return 1;
        fi;

        endpoint1="$COMMON_ANCESTOR";
    done

    echo "$COMMON_ANCESTOR";
}

# Source this function to leverage git-bash-completion.sh with git graph
# _git_graph()
# {
#       # you can return anything here for the autocompletion for example all
#       # the branches
#       __gitcomp_nl "$(__git_refs)"
# }

main $@;
