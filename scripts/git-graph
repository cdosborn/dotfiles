#!/bin/bash

#
# Print a handy graph of some refs.
#
# `git graph master feature` will print a graph which includes the feature and
# master, but omits the long history they have in common.
#
# You could achieve the above rougly with:
#
#   git log --graph --oneline master feature ^$(git merge-base master feature)
#
# But this has a shortcoming. If feature gets merged into master several
# times. You'll only see since the last merge. `git graph` will show you the
# larger picture, i.e. the branches since their first shared ancestor.
#

function usage {
    echo 'Print the shared history of git refs';
    echo '';
    echo 'git graph <ref 1> <ref 2>     # Pass several refs to graph';
    echo 'git graph ... -- <path>       # Filter commits which affected <path';
    echo 'git graph --single-parent     # Pass options know to git log';
    echo 'git graph --echo              # Just print the underlying git command';
    echo 'git graph --bash-completion   # Print bash completion code';
    echo 'git graph --help              # Print this message';
}

function main {
    local REFS FLAGS FILES;
    local ECHO_GIT_COMMAND=0; # false
    FLAGS=(
        '--graph' \
        '--oneline' \
        '--format=format:%C(auto)%h%C(reset)%C(auto)%d%C(reset) %C(auto)%<(50,trunc)%s %C(reset)'
    );

    if [[ "$#" -eq 0 ]]; then
        usage;
        return 0;
    fi

    # Parse arguments
    while [ "$#" -gt 0 ]; do
        if [ "$1" == '--help' ]; then
            usage;
            exit 0;
        elif [ "$1" == '--bash-completion' ]; then
             print_bash_completion;
             exit 0;
        elif [ "$1" == '--echo' ]; then
            ECHO_GIT_COMMAND=1;
        elif [ "$1" == '--' ]; then
            FILES+=( "$@" );
            break;
        elif [[ "$1" =~ ^- ]]; then
            FLAGS+=( "$1" );
        else
            REFS+=( "$1" );
        fi
        shift;
    done;

    if [ "${#REFS[@]}" -eq 0 ]; then
        echo "Err! 1 or more refs required" >&2;
        usage >&2;
        return 1;
    fi

    # If only one ref is passed, make this invocation equivalent to:
    # `git graph <ref> HEAD`
    if [ "${#REFS[@]}" -eq 1 ]; then
        REFS+=( HEAD );
    fi

    # Validate the refs
    for ref in "${REFS[@]}"; do
        git rev-parse --verify "$ref" &>/dev/null;
        if [ "$?" -ne 0 ]; then
           echo "Err! this is an invalid ref: $ref" >&2;
           exit 1;
        fi;
    done;


    local MERGE_BASE=$(oldest-merge-base "${REFS[@]}");
    local NEGATION_SET=();

    # Only compute negation set, if a merge base exists
    if [ -n "$MERGE_BASE" ]; then

        # We want to show the merge base of the tips, but no further, in the
        # usual case a merge base has parents, and we hide these parents, by
        # adding them to the NEGATION_SET, if there are no parents, MERGE_BASE
        # is the root and we don't need to exclude anything
        for parent in $(git log --format=%P $MERGE_BASE -n 1); do
            NEGATION_SET+=( "^$parent" );
        done;
    fi

    local COMMAND=( git log "${FLAGS[@]}" "${NEGATION_SET[@]}" "${REFS[@]}" -- "${FILES[@]}" );
    if [ "$ECHO_GIT_COMMAND" -eq 1 ]; then
        echo_args "${COMMAND[@]}"
    else
       "${COMMAND[@]}";
    fi
}

function oldest-merge-base {
    local COMMON_ANCESTOR="" endpoint1 endpoint2;
    endpoint1="$1";

    # To handle more than 2 endpoints, we compute like so
    # o-m-b(o-m-b(o-m-b($1, $2), $3), ...)
    while [[ "$#" -gt 1 ]]; do
        shift;
        endpoint2="$1";

        while read sha1 <&3  && read sha2 <&4
        do
            if [ "$sha1" == "$sha2" ]; then
                COMMON_ANCESTOR="$sha1";
            else
                # Break at the first occurence where the history diverged
                break;
            fi;

        done 3< <(git rev-list --reverse --first-parent "$endpoint1" --) 4< <(git rev-list --reverse  --first-parent "$endpoint2" -- )

        # When comparing the two histories from their starts, we never found
        # a branching off point
        if [ -z "$COMMON_ANCESTOR" ]; then
            return 1;
        fi;

        endpoint1="$COMMON_ANCESTOR";
    done

    echo "$COMMON_ANCESTOR";
}

# Print quoted arguments
function echo_args {
    while [ "$#" -gt 1 ]; do
        printf "%q " "$1";
        shift;
    done;
    if [ "$#" -eq 1 ]; then
        printf "%q" "$1";
        echo;
    fi;
}

function print_bash_completion {
  cat <<'EOF'
# Source me, so that git graph support git completion!
# Requires git bash completion.
function git_graph
{
      __gitcomp_nl "$(__git_refs)"
}
EOF
}

main $@;
